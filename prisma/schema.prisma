// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// BetterAuth tables

model User {
  id            String   @id @default(cuid())
  name          String?
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  brokerProfile BrokerProfile?

  accounts Account[]
  sessions Session[]

  // Custom fields for insurance platform
  role        UserRole @default(BROKER)
  companyName String?
  phone       String?
  address     String?
  siretNumber String?
  isActive    Boolean  @default(true)

  // Relations
  projects Project[]
  messages Message[]

  // Quote messages relations
  sentQuoteMessages     QuoteMessage[] @relation("SentQuoteMessages")
  receivedQuoteMessages QuoteMessage[] @relation("ReceivedQuoteMessages")

  // Insurance relations
  quotes             Quote[]
  contracts          InsuranceContract[]
  commissions        Commission[]
  notifications      Notification[]
  createdProducts    InsuranceProduct[] // Produits créés par les admins
  validatedDocuments QuoteDocument[]     @relation("DocumentValidator")
  passwordResets     PasswordReset[]

  // Workflow relations
  assignedSteps WorkflowStep[] @relation("AssignedSteps")
  stepMessages  StepMessage[]
  stepTemplates StepTemplate[]

  // Payment validation relations
  validatedPayments PaymentInstallment[] @relation("PaymentValidator")
  validatedTransactions PaymentTransaction[] @relation("TransactionValidator")

  // Document request relations
  requestedDocuments DocumentRequest[] @relation("RequestedDocuments")

  @@map("users")
}

model BrokerProfile {
  id     String @id @default(cuid())
  userId String @unique @map("user_id")
  user   User   @relation(fields: [userId], references: [id])
  code   String

  @@map("broker_profiles")
}

// Insurance platform models

enum UserRole {
  BROKER
  ADMIN
  UNDERWRITER
}

enum ProjectType {
  NEW_CONSTRUCTION
  RENOVATION
  EXTENSION
  MULTI_RISK
}

enum ProjectStatus {
  DRAFT

  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  ACTIVE
  COMPLETED
}

model Client {
  id        String   @id @default(cuid())
  firstName String
  lastName  String
  email     String
  phone     String?
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects Project[]

  @@map("clients")
}

model Project {
  id          String        @id @default(cuid())
  title       String
  description String?
  type        ProjectType
  status      ProjectStatus @default(DRAFT)
  startDate   DateTime?
  endDate     DateTime?
  budget      Float?
  address     String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  brokerId String @map("broker_id")
  broker   User   @relation(fields: [brokerId], references: [id])
  clientId String @map("client_id")
  client   Client @relation(fields: [clientId], references: [id])

  questionnaire Questionnaire?
  documents     Document[]
  contract      Contract?
  messages      Message[]

  @@map("projects")
}

model Questionnaire {
  id        String   @id @default(cuid())
  projectId String   @unique @map("project_id")
  responses Json // Store form responses as JSON
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("questionnaires")
}

model Document {
  id         String   @id @default(cuid())
  fileName   String
  fileUrl    String
  fileType   String
  fileSize   Int
  projectId  String   @map("project_id")
  uploadedAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("documents")
}

model Contract {
  id          String    @id @default(cuid())
  projectId   String    @unique @map("project_id")
  contractUrl String?
  signedAt    DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("contracts")
}

model Message {
  id        String   @id @default(cuid())
  content   String
  projectId String   @map("project_id")
  senderId  String   @map("sender_id")
  createdAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  sender  User    @relation(fields: [senderId], references: [id])

  @@map("messages")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

// Generic Insurance Product System

enum QuoteStatus {
  DRAFT
  INCOMPLETE
  SUBMITTED
  IN_PROGRESS
  COMPLEMENT_REQUIRED
  OFFER_READY
  OFFER_SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

enum ContractStatus {
  ACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
  PENDING_RENEWAL
}

enum PaymentStatus {
  PENDING
  PAID
  OVERDUE
  DISPUTED
}

enum CommissionStatus {
  PENDING
  EARNED
  PAID
}

enum NotificationType {
  CONTRACT_EXPIRATION
  PAYMENT_DUE
  OFFER_READY
  COMPLEMENT_REQUIRED
  RENEWAL_DUE
  GENERAL
}

enum DocumentType {
  KBIS
  FINANCIAL_STATEMENT
  INSURANCE_CERTIFICATE
  SIGNED_QUOTE
  CONTRACT
  ATTESTATION
  OTHER
}

// Core product definition - configurable by admin
model InsuranceProduct {
  id          String  @id @default(cuid())
  name        String // "RC Décennale", "RC Professionnelle", etc.
  code        String  @unique // "RCD", "RCP", "MR"
  description String?
  isActive    Boolean @default(true)

  // Product configuration (JSON fields for flexibility)
  formFields     Json // Dynamic form field definitions with step support
  pricingRules   Json // Pricing calculation rules
  requiredDocs   Json // Required document types
  workflowConfig Json? // Custom workflow steps
  stepConfig     Json? // Multi-step form configuration
  mappingFields  Json? // Mapping fields

  // Relations
  quotes    Quote[]
  contracts InsuranceContract[]

  // Audit
  createdById String   @map("created_by_id")
  createdBy   User     @relation(fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("insurance_products")
}

// Generic quote model that works for any insurance product
model Quote {
  id        String      @id @default(cuid())
  reference String      @unique
  status    QuoteStatus @default(DRAFT)

  // Product relation
  productId String           @map("product_id")
  product   InsuranceProduct @relation(fields: [productId], references: [id])

  // Client company information (dynamic based on product)
  companyData Json // All company-specific data (name, siret, address, etc.)

  // Quote specifics
  formData          Json // All form data specific to the product
  calculatedPremium Json?
  validUntil        DateTime?

  // Workflow
  submittedAt  DateTime?
  offerReadyAt DateTime?
  offerSentAt  DateTime?
  acceptedAt   DateTime?

  // Relations
  brokerId String @map("broker_id")
  broker   User   @relation(fields: [brokerId], references: [id])

  documents QuoteDocument[]
  contract  InsuranceContract?
  workflowSteps WorkflowStep[]
  paymentSchedule PaymentSchedule?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Chat messages for this quote
  quoteMessages QuoteMessage[]

  // Additional document requests from admin
  documentRequests DocumentRequest[]

  @@map("quotes")
}

// Chat messages for quotes between broker and admin
model QuoteMessage {
  id      String @id @default(cuid())
  content String

  // Quote relation
  quoteId String @map("quote_id")
  quote   Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  // Sender and receiver (broker <-> admin)
  senderId   String @map("sender_id")
  sender     User   @relation("SentQuoteMessages", fields: [senderId], references: [id])
  receiverId String @map("receiver_id")
  receiver   User   @relation("ReceivedQuoteMessages", fields: [receiverId], references: [id])

  // Message status
  isRead Boolean   @default(false)
  readAt DateTime?

  // Attachments
  attachments QuoteMessageAttachment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("quote_messages")
}

// Attachments for quote messages
model QuoteMessageAttachment {
  id        String       @id @default(cuid())
  messageId String       @map("message_id")
  message   QuoteMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  fileName     String
  originalName String
  filePath     String
  fileType     String
  fileSize     Int

  uploadedAt DateTime @default(now())

  @@map("quote_message_attachments")
}

// Generic contract model
model InsuranceContract {
  id        String         @id @default(cuid())
  reference String         @unique
  status    ContractStatus @default(ACTIVE)

  // Link to accepted quote
  quoteId String @unique @map("quote_id")
  quote   Quote  @relation(fields: [quoteId], references: [id])

  // Contract terms
  startDate     DateTime
  endDate       DateTime
  annualPremium Float
  paymentStatus PaymentStatus @default(PENDING)
  lastPaymentAt DateTime?

  // Relations
  brokerId String @map("broker_id")
  broker   User   @relation(fields: [brokerId], references: [id])

  documents   ContractDocument[]
  commissions Commission[]

  // Generated document URLs (local storage paths)
  attestationPath        String? // Insurance certificate
  contractPath           String? // Full contract
  specificConditionsPath String? // Specific conditions
  coverageNotePath       String? // Coverage note

  // Renewal management  
  renewalDate     DateTime?
  isAutoRenewal   Boolean   @default(true)
  renewalNotified Boolean   @default(false)

  // Insurance product relation
  productId String           @map("product_id")
  product   InsuranceProduct @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("insurance_contracts")
}

// Generic document model for quotes
model QuoteDocument {
  id           String @id @default(cuid())
  fileName     String
  originalName String
  filePath     String // Local file path
  fileType     String
  fileSize     Int
  documentType String //DocumentType

  quoteId    String  @map("quote_id")
  quote      Quote   @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  isVerified Boolean @default(false)

  // Document validation fields
  validationNotes String?
  validatedAt     DateTime?
  validatedById   String?   @map("validated_by_id")
  validatedBy     User?     @relation("DocumentValidator", fields: [validatedById], references: [id])

  uploadedAt DateTime @default(now())

  // Document request relations
  fulfillsRequests DocumentRequest[] @relation("FulfillsRequest")

  @@map("quote_documents")
}

// Generic document model for contracts
model ContractDocument {
  id           String       @id @default(cuid())
  fileName     String
  originalName String
  filePath     String // Local file path
  fileType     String
  fileSize     Int
  documentType DocumentType

  contractId String            @map("contract_id")
  contract   InsuranceContract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  uploadedAt DateTime @default(now())

  @@map("contract_documents")
}

// Document requests for additional documents beyond product requirements
model DocumentRequest {
  id          String @id @default(cuid())
  quoteId     String @map("quote_id")
  quote       Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  // Document request details
  documentType String // Type de document demandé
  description  String? // Description optionnelle de ce qui est attendu
  isRequired   Boolean @default(true)

  // Who requested it
  requestedById String @map("requested_by_id")
  requestedBy   User   @relation("RequestedDocuments", fields: [requestedById], references: [id])
  requestedAt   DateTime @default(now())

  // Status
  isFulfilled Boolean @default(false)
  fulfilledAt DateTime?

  // Which document fulfilled this request (optional)
  fulfilledByDocumentId String? @map("fulfilled_by_document_id")
  fulfilledByDocument   QuoteDocument? @relation("FulfillsRequest", fields: [fulfilledByDocumentId], references: [id])

  // Notes
  adminNotes   String? // Notes de l'admin
  brokerNotes  String? // Réponse du broker

  @@map("document_requests")
}

// Commission tracking
model Commission {
  id         String @id @default(cuid())
  contractId String @map("contract_id")
  brokerId   String @map("broker_id")

  // Commission calculation
  basePremium      Float
  commissionRate   Float // Percentage
  commissionAmount Float // Calculated amount

  // Status and timing
  status  CommissionStatus @default(PENDING)
  dueDate DateTime
  paidAt  DateTime?

  // Relations
  contract InsuranceContract @relation(fields: [contractId], references: [id])
  broker   User              @relation(fields: [brokerId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("commissions")
}

// Notification system
model Notification {
  id      String           @id @default(cuid())
  type    NotificationType
  title   String
  message String

  // Targeting
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id])

  // Status
  isRead   Boolean   @default(false)
  isUrgent Boolean   @default(false)
  readAt   DateTime?

  // Related entity (optional)
  relatedEntityType String? // "quote", "contract", "product"
  relatedEntityId   String? // Entity ID

  // Scheduling
  scheduledFor DateTime?
  sentAt       DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("notifications")
}

model PasswordReset {
  id      String   @id @default(cuid())
  userId  String   @map("user_id")
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token   String   @unique
  expires DateTime
  used    Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("password_resets")
}

model BrokerInvitation {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  companyName String
  phone       String
  address     String
  siretNumber String?
  brokerCode  String   @unique
  token       String   @unique
  expires     DateTime
  used        Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("broker_invitations")
}

// Workflow System Models

enum StepStatus {
  PENDING
  ACTIVE
  COMPLETED
  SKIPPED
}

enum MessageType {
  ADMIN_INSTRUCTION
  BROKER_QUESTION
  BROKER_RESPONSE
  SYSTEM_NOTIFICATION
}

enum InputType {
  TEXT
  TEXTAREA
  SELECT
  DATE
  FILE
  CHECKBOX
}

// Modèle principal pour les étapes de workflow
model WorkflowStep {
  id        String     @id @default(cuid())
  quoteId   String     @map("quote_id")
  quote     Quote      @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  
  // Configuration de l'étape
  title       String
  description String?
  order       Int       // Ordre d'exécution
  status      StepStatus @default(PENDING)
  
  // Assignation et échéance
  assignedToBrokerId String? @map("assigned_to_broker_id")
  assignedToBroker   User?   @relation("AssignedSteps", fields: [assignedToBrokerId], references: [id])
  dueDate           DateTime?
  
  // Template
  isTemplate Boolean @default(false)
  templateId String? @map("template_id")
  template   StepTemplate? @relation(fields: [templateId], references: [id])
  
  // Relations
  inputs   StepInput[]
  messages StepMessage[]
  
  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("workflow_steps")
}

// Modèle pour les inputs dynamiques des étapes
model StepInput {
  id        String    @id @default(cuid())
  stepId    String    @map("step_id")
  step      WorkflowStep @relation(fields: [stepId], references: [id], onDelete: Cascade)
  
  // Configuration de l'input
  type        InputType
  label       String
  placeholder String?
  required    Boolean  @default(false)
  options     Json?    // Pour les inputs de type SELECT
  validationRules Json? // Règles de validation personnalisées
  
  // Valeur saisie par le broker
  value       Json?    // Valeur stockée
  submittedAt DateTime?
  
  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("step_inputs")
}

// Modèle pour les messages dans les étapes
model StepMessage {
  id        String      @id @default(cuid())
  stepId    String      @map("step_id")
  step      WorkflowStep @relation(fields: [stepId], references: [id], onDelete: Cascade)
  
  // Contenu du message
  content     String
  type        MessageType
  
  // Auteur
  authorId   String @map("author_id")
  author     User   @relation(fields: [authorId], references: [id])
  
  // Statut
  isRead     Boolean @default(false)
  readAt     DateTime?
  
  // Relations
  attachments StepMessageAttachment[]
  
  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("step_messages")
}

// Modèle pour les pièces jointes des messages
model StepMessageAttachment {
  id        String      @id @default(cuid())
  messageId String      @map("message_id")
  message   StepMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  // Fichier
  fileName     String
  originalName String
  filePath     String
  fileType     String
  fileSize     Int
  
  // Audit
  uploadedAt DateTime @default(now())
  
  @@map("step_message_attachments")
}

// Modèle pour les templates d'étapes
model StepTemplate {
  id          String @id @default(cuid())
  name        String
  description String?
  
  // Configuration du template
  title       String
  
  // Inputs par défaut du template
  defaultInputs Json // Array de StepInput configs
  
  // Utilisation
  isActive    Boolean @default(true)
  usageCount  Int     @default(0)
  
  // Relations
  steps WorkflowStep[] // Étapes créées à partir de ce template
  
  // Audit
  createdById String   @map("created_by_id")
  createdBy   User     @relation(fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("step_templates")
}

// Payment Schedule System Models

enum PaymentScheduleStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
  PARTIALLY_PAID
}

enum PaymentMethod {
  CASH
  CHECK
  BANK_TRANSFER
  CARD
  SEPA_DEBIT
  OTHER
}

// Échéancier principal d'un devis
model PaymentSchedule {
  id        String @id @default(cuid())
  quoteId   String @unique @map("quote_id")
  quote     Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  // Informations générales de l'échéancier
  totalAmountHT  Float
  totalTaxAmount Float
  totalAmountTTC Float

  // Période couverte
  startDate DateTime
  endDate   DateTime

  // Statut global
  status PaymentScheduleStatus @default(PENDING)

  // Relations
  payments PaymentInstallment[]

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payment_schedules")
}

// Échéances individuelles
model PaymentInstallment {
  id         String @id @default(cuid())
  scheduleId String @map("schedule_id")
  schedule   PaymentSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  // Informations de l'échéance
  installmentNumber Int // Numéro d'ordre (1, 2, 3...)
  dueDate          DateTime

  // Montants
  amountHT  Float
  taxAmount Float
  amountTTC Float

  // Détail des primes (comme dans calculationResult.echeancier.echeances)
  rcdAmount     Float? // RC Décennale
  pjAmount      Float? // Protection Juridique
  feesAmount    Float? // Frais
  resumeAmount  Float? // Reprise

  // Période de validité des attestations
  periodStart DateTime
  periodEnd   DateTime

  // Statut de paiement
  status PaymentScheduleStatus @default(PENDING)

  // Informations de paiement
  paidAt     DateTime?
  paidAmount Float?    @default(0)
  paymentMethod PaymentMethod?
  paymentReference String? // Référence du paiement (numéro de chèque, virement, etc.)

  // Notes administratives
  adminNotes String?
  brokerNotes String?

  // Qui a validé le paiement
  validatedById String? @map("validated_by_id")
  validatedBy   User?   @relation("PaymentValidator", fields: [validatedById], references: [id])
  validatedAt   DateTime?

  // Notifications
  lastReminderSent DateTime?
  reminderCount    Int @default(0)

  // Relations
  transactions PaymentTransaction[]

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payment_installments")
}

// Transactions de paiement (historique des paiements partiels ou multiples)
model PaymentTransaction {
  id            String @id @default(cuid())
  installmentId String @map("installment_id")
  installment   PaymentInstallment @relation(fields: [installmentId], references: [id], onDelete: Cascade)

  // Détails de la transaction
  amount    Float
  method    PaymentMethod
  reference String? // Numéro de chèque, référence virement, etc.

  // Validation
  validatedById String? @map("validated_by_id")
  validatedBy   User?   @relation("TransactionValidator", fields: [validatedById], references: [id])
  validatedAt   DateTime?

  // Notes
  notes String?

  // Documents justificatifs
  proofDocumentPath String? // Chemin vers le justificatif de paiement

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payment_transactions")
}
